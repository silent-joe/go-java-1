23.01.2015 10:10

Category class:

	1. Не нужно в конструкторе указывать значение по умолчанию (конструктор пустой)
	   И вообще, такая структура не рекомендуется к использованию.
	   Какова цель использование ее? Нужно удалить эту запись!
	   
			name =  new String();
			
	   Если у тебя будет значение null - это значит, что поле не проинициализировалось
	   и будет ясно, что нужн осмотреть в источник данных - почему там нету значения.
	   
	   Если ты установил по умолчанию пустую строку - то это уже установленное поле,
	   и в первую очередь возникнет вопрос - в источнике нету значения, а у нас есть!
	   и время будет тратиться на поиск ошибки. а не решения главных задач. 
	   		
Good сlass:

	1. 	public Good() {
			name = new String();
			category = new Category();
		}
		аналогично предыдущему комментарию.
		К тому же присваиваяя категории объект по умолчанию - потенциальная ошибка в бизнес логике.
		Так как возможна бизнес логика подобного типа:
			public boolean hasCategory(Good good) {
				return good != null && good.getCategory() != null;
			}
		и такое построение бизнес логики будет более правым, чем подобная запись в конструкторе.

GoodStorageImpl.getGoodList method:

	Привожу две реализации. Существующий вариант не валидный, поскольку только наш частный случай гарантирует
	что tempGood.getCategory() == category. На практике такого не будет.
	
		public List<Good> getGoodList(Category category) {
			final List<Good> result = new ArrayList<Good>();
			if (category == null) {
				return result;
			}
			for (Good good : goodList){
				if (category.equals(good.getCategory())) {
					result.add(good);
				}
			}
			return result;
		}
	
		public List<Good> getGoodList(Category category) {
			final List<Good> result = new ArrayList<Good>();
			final String categoryName = category.getName();
			if (category == null || categoryName == null) {	
				return result;			
			}		
			for (Good good : goodList){
				if (good.getCategory() != null && categoryName.equals(good.getCategory().getName())) {	
					result.add(good);
				}
			}
			return result;
		}	

	Если мы объявляем, что возвращаем список, то не нужно возвращать null.
	Нету данных - возвращать пустой список.
	
GoodStorageImpl.getGoodList method:

	лучше реализовать так: return goodList != null ? goodList : new ArrayList<Good>();

 
Test classes:
	
	1. Более правильно объявить так:
	
			import static org.junit.Assert.*;
			public class CategoryTest {
			    ....	
	2. в нашем случае не нужно так детально описывать, поскольку получается, что тест пишем ради теста 
	   а не проверки функциональности. 
	   
CategoryTest.class:

	1. слишком много тестов. Думаю будет достаточно такого 
	   (так как наш бин простой, и ничего особо тестировать не нужно)	
			@Test
			public void createInstanceTest() {
				final Category categoryEmpty = new Category();
				assertNull(categoryEmpty.getName());
				
				final Category categorySetter = new Category();
				categorySetter.setName("default");
				assertEquals("default", categorySetter.getName());
				
				final Category categoryConstructor = new Category("default");
				assertEquals("default", categoryConstructor.getName());		
			}	   

	2. тестировать junit framework не нужно (хотя Сергей другого мнения):
					@Test
					public void testSmoke() {
						assertNotNull(category);
					}
					
GoodStorageImplTest.class:
	Думаю, что достаточно сделать только следующие тесты, и в них описать все ассерты:
						
		@Test
		public void getCategoryListTest();
							
		@Test
		public void getGoodList();
					
======================================

21.01.2015 22:40:

Category class

	1. порядок полей - изменить
		1. переменные
		2. конструкторы
		3. методы, сначала твои, в конце toString()
		
	2. Конструктор:
		1. super() - будет вызван по умолчанию
		2. если делаешь конструктор с аргументами - делай конструктор по умолчанию.
		3. в java bean лучше не использовать кастомный конструктор. но в реализации
		   он используется для простого кода создания набора данных, потому его лучше
		   сделать protected
		
Good class:

	1. см предыдущее описание
	2. конструктор, порядок лучше сделать таким: int id, String name, Category category
	    причина - важность данных
	    
GoodStorageInMemory class:
	
	1. см предыдущие комментарии
	2. лучше переименовать в GoodStorageImpl
	3. лучшу убрать методы инициализации, а инициализацию сделать так:
			private List<Category> categoryList = new ArrayList<Category>() {{
				this.add(new Category("Guitars")));
			}};
	4. goods и categories переименовать в goodList, categoryList: у нас же список
	
GoodStorageInMemory.getGoodList method:
	
	1. я аргументом могу передать null, лучше сделать вначале проверку и если null-
	   вернуть пусток список
	   
	2. Допустим, мы из inputStream получили имя категории Guitars
	   и хотим получить список good для єтой категории. соотв наш код будет:
	   List<Good> goodList = service.getGoodList(new Category("Guitars"));
	   будет работать?
	   
Main class:	   
	1. метод printGoodsInCategory представит как  private static void printCategory(Category category, PrintStream stream);
	2. реализовать use cases:
		1. получить из сервиса список всех категорий
		2. отобразить список категорий
		3. для каждой из категорий получить список goods и отобразить их.
		
MyShopUML.pdf, README, user_story files
	1. перенеcти в /project/doc
	
UML: 
	1. GoodStorageInMemory:	
		1. я бы не указывал связи с java beans. связь видна из декларации методов.
		
	2. Good:
		1. агрегирует Category
		     вопрос: может ли существовать Good без Сategory? 
		     если да, то ромбик зарисовываем
	
	
	 
======================================================


21.01.2015 01:00

Goods class:

	1. Классы именуются в единственном числе
	2. Между методами и свойствами необходима пустая строка.
	
	
Goods.maxID	

	В java bean не нужно  использовать такой подход к генерации идентификаторов.
	
	Так как мы грузим бины откуда-то, и пускай это что-то присваивает идентификаторы,
	в текущей реализации это GoodsStorage. Потому я бы удалил данный подход генерации комментариев из бинов.
	
	Соответственно изменится конструктор: public Goods(int id, String category, String name) {
	protected - поскольку еще не определн список аргументов, и этот конструктор используется только для удобного создания бина в нашем хранилише, и больше ни где
	
	Для почитать и изучить: http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicInteger.html	
	
Архитектура:

	1. Необходимо создать класс, скажем ShopService(Impl) который реализовывал бы следующие методы:	
		public List<Category> getCategoryList() { ... }
		public List<Good> getGoodList(Category category) { ... }
	   использование интерфейса по желанию.
	  
	2. наш сервис по работе с данными не должен реализовывать ни каких print методов, ни каких System.out/in
	
	3. внутренее хранилище можно инициализировать так:
		private final List<Good> goods = new ArrayList<Good>() {{
			this.add(new Good(...));
			this.add(new Good(...));
		}};
		
	4. Если есть желание поработать с выводом в консоль "красиво", то в main-классе реализовать следующие методы (и вызвать их из main метода):
		public static void print(List<Good> goodList, OutputStream os) {....}
		public static void print(List<Category> categoryList, OutputStream os) {....}
	
	5. резюме: бизнеслогика не должна ничего ни куда выводить, на текущий момент мы выводим только из main
	   в дальнейшем main-метод у нас исчезнет. его заменят unit-тесты.