21.01.2015 22:40:

Category class

	1. порядок полей - изменить
		1. переменные
		2. конструкторы
		3. методы, сначала твои, в конце toString()
		
	2. Конструктор:
		1. super() - будет вызван по умолчанию
		2. если делаешь конструктор с аргументами - делай конструктор по умолчанию.
		3. в java bean лучше не использовать кастомный конструктор. но в реализации
		   он используется для простого кода создания набора данных, потому его лучше
		   сделать protected
		
Good class:

	1. см предыдущее описание
	2. конструктор, порядок лучше сделать таким: int id, String name, Category category
	    причина - важность данных
	    
GoodStorageInMemory class:
	
	1. см предыдущие комментарии
	2. лучше переименовать в GoodStorageImpl
	3. лучшу убрать методы инициализации, а инициализацию сделать так:
			private List<Category> categoryList = new ArrayList<Category>() {{
				this.add(new Category("Guitars")));
			}};
	4. goods и categories переименовать в goodList, categoryList: у нас же список
	
GoodStorageInMemory.getGoodList method:
	
	1. я аргументом могу передать null, лучше сделать вначале проверку и если null-
	   вернуть пусток список
	   
	2. Допустим, мы из inputStream получили имя категории Guitars
	   и хотим получить список good для єтой категории. соотв наш код будет:
	   List<Good> goodList = service.getGoodList(new Category("Guitars"));
	   будет работать?
	   
Main class:	   
	1. метод printGoodsInCategory представит как  private static void printCategory(Category category, PrintStream stream);
	2. реализовать use cases:
		1. получить из сервиса список всех категорий
		2. отобразить список категорий
		3. для каждой из категорий получить список goods и отобразить их.
		
MyShopUML.pdf, README, user_story files
	1. перенеcти в /project/doc
	
UML: 
	1. GoodStorageInMemory:	
		1. я бы не указывал связи с java beans. связь видна из декларации методов.
		
	2. Good:
		1. агрегирует Category
		     вопрос: может ли существовать Good без Сategory? 
		     если да, то ромбик зарисовываем
	
	
	 
======================================================


21.01.2015 01:00

Goods class:

	1. Классы именуются в единственном числе
	2. Между методами и свойствами необходима пустая строка.
	
	
Goods.maxID	

	В java bean не нужно  использовать такой подход к генерации идентификаторов.
	
	Так как мы грузим бины откуда-то, и пускай это что-то присваивает идентификаторы,
	в текущей реализации это GoodsStorage. Потому я бы удалил данный подход генерации комментариев из бинов.
	
	Соответственно изменится конструктор: public Goods(int id, String category, String name) {
	protected - поскольку еще не определн список аргументов, и этот конструктор используется только для удобного создания бина в нашем хранилише, и больше ни где
	
	Для почитать и изучить: http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicInteger.html	
	
Архитектура:

	1. Необходимо создать класс, скажем ShopService(Impl) который реализовывал бы следующие методы:	
		public List<Category> getCategoryList() { ... }
		public List<Good> getGoodList(Category category) { ... }
	   использование интерфейса по желанию.
	  
	2. наш сервис по работе с данными не должен реализовывать ни каких print методов, ни каких System.out/in
	
	3. внутренее хранилище можно инициализировать так:
		private final List<Good> goods = new ArrayList<Good>() {{
			this.add(new Good(...));
			this.add(new Good(...));
		}};
		
	4. Если есть желание поработать с выводом в консоль "красиво", то в main-классе реализовать следующие методы (и вызвать их из main метода):
		public static void print(List<Good> goodList, OutputStream os) {....}
		public static void print(List<Category> categoryList, OutputStream os) {....}
	
	5. резюме: бизнеслогика не должна ничего ни куда выводить, на текущий момент мы выводим только из main
	   в дальнейшем main-метод у нас исчезнет. его заменят unit-тесты.