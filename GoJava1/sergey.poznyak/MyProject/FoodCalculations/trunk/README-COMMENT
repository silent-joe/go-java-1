04.02.2015 23:40

UserMenu class

	Используется поле peopleNum - на какое к-во людей готовится блюдо.
	Но, когда планируется меню, то разные блюда могут готовиться на разное к-во людей.
	Пример: картошку с кроликом всем, селедку - мужикам, сладкое + не вредное - детям.
	
	Т.Е. в метод public void addDsih(Dish dish); необходимо добавить поле к-во персон.
	получим public void add(Dish dish, int peopleNumber);
	
	Но в тот же момент определенное блюдо (его рецепт) расчитано, по умолчанию, на
	определенное минимальное к-во порций (возможно это свойство необходимо сделать обязательным
	в объекте блюдо).
	
	Потому, добавлять в меню блюдо можно для к-ва персон кратных рецепту.
	Пример: рецепт борщ предполагает 3 порции. Потому в меню можно добавить 3, 6, 9 борщей.
	Как это реализовать - на твое усмотрение.
	
UserMenu#calculateWeights method

	внутри метода используется List<Foodstuff> foodstuffList = ListServiceHardcodedData.getFoodstuffList();
	Это не правильно. 
	Метод java bean'а должен производить вычисления на основании информации доступной ему, без использования
	внешних ресов. К тому же у тебя все этого есть:
	
	   Меню знает какие блюда и на какое к-во персон какое блюдо необходимо приготовить.
	   Блюдо знает какое к-во каких инградиентов ему необходимо.
	   
	Если в логике работы метода java bean'a возникает потребность в сторонних ресурсах, тогда
	эту логику необходимо выность в какой-то сервис.
	
Общие замечания:

   Если в бине есть private List<?> objectList;, то
   1. setter не нужен
   2. getter в 99.9999% достаточный такого вида:
   			public List<?> getObjectList() {
   			   if (this.objectList == null) {
   			      this.objectList = new ArrayList<?>();
   			   }
   			   return this.objectList;
			}
			
			
	toString вообще не информативные.
	
UML:
	лучше модель объектов рисовать  отдельно.
	Если она оказывается не самодостаточной, то значит мы копаем не туда. 
	
Предлагаю обсудить выше изложенные вопросы, а потом перейдем к Ingradient class.
Есть определенные мысли.
			
=======================================

29.01.2015 13:40

1. Foodstuff лучше переименовать в FoodStuff. Какова цель этого class?

2. ListServiceHardcodedDataTest
      нужно в @Before создавать инстанс сервиса, и дальше в тестах вызывать его
      методы для получения данных и полученные данные тестировать.
      
      То как реализовано сейчас - ошибка
      
3. Какова цель переопределения hashcode и equals?
   Хотелось бы услышать довод.
   
       
   
================================

27.01.2015

Изменений пока нету?

================================

22.01.2015 21:50

Dish class:

	 Існує два конструктора
		public Dish() {
			id = 0;
			name = "";
		}
	
		public Dish(int dishId, String dishName) {
			id = dishId;
			name = dishName;
		}		
	  на практиці може бути більше, і найкраще робити ініціалізацію в одному конструкторі.
	  тому, в поточній моделі, в дефолтному конструкторі краще зробити:
	  
	  	this(0, null);
	  	
	  Але в ідеалі не потрібно присвоювати будь які значення в бінах, якщо на те нема явної
	  потреби. Нехай цю роботу робить клас котрий породжує інстанс біна, тоді в майбутньому 
	  не буде проблем зі значенням по замовчуванню.
	  
	  Значення String = "" - теж краще не робити. Якщо у рядка нема значення, значить null.
	  
	  Відповідно, в цьому білі змінні мають бути:
	  
	  	private Integer id;
	  	
	  	private String name;

Ingredient class:

	див попередній коментар.
	
	в класі використосовується weight в кілограмах, відповідно для користувача буде відображено 0.005 кг.
	або ж користувач буде вводити 0.005кг?
	usability постраждає. 
	
	але в рецептах вага задається в грамах, але може бути і літр.
	
	пропоную подумати (поки не реалізовувати в основному коді) як можна відрефакторити.
	Гадаю, що enum буде в пригоді.
	
ListServiceHardcodedData сlass

	за звичай існує лише одне джерело даних.
	зараз це - harcode data.
	Потім задача буде змінюватись, і джерело буде іншим і єдиним на той момент.
	А клас сервісу стане не актуальним. Видаливши його - доведеться робити правки в багатьох місцях.
	Тому реалізацію сервіса краще відразу задати однозначно, і рефакторити лише бізнес логіку в даному класі.
	
	тому, правильно буде дані ініціалізувати так:
	
		private List<Dish> dishesList = new ArrayList<Dish>() {{
			this.add(new Dish(1, "Borshch"));
			this.add(new Dish(2, "Buckwheat porridge"));
			this.add(new Dish(3, "Rice porridge"));
			this.add(new Dish(4, "Buckwheat soup"));
			this.add(new Dish(5, "Pasta with meat"));		
		}};	
	а в методах сервісу реалізувати бізнес логіку.
	і я наполягаю на цьому.
================================================

20.01.2015 23:30

Dish class:

	Это java bean, потому более правильно описание делать:
		The Dish bean.
		<empty line>
		This bean describes blabla
		
Dish.nextId field:

	В java bean не нужно  использовать такой подход к генерации идентификаторов.
	
	Так как мы грузим бины откуда-то, и пускай это что-то присваивает идентификаторы,
	в текущей реализации это DishStorage. Потому я бы удалил данный подход генерации комментариев из бинов.
	
	Соответственно изменится конструктор: protected Dish(int dishId, String dishName)
	protected - поскольку еще не определн список аргументов, и этот конструктор используется только для удобного создания бина в нашем хранилише, и больше ни где
	
	Для почитать и изучить: http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicInteger.html	
	
DishStorage class:

	Мой пример был неудачным, чем я подтолкнул к применению плохой практики
	В нашей задаче этот функционал (хранение данных) лучше поместить в твой сервис, а этот клас удалить.
	Приношу свои извинения.
	
	К тому же я бы отказался от использования статического сиквенса для инициализации идентификаторов, лучше на текущем этапе захардкодить:
		dishList.add(new Dish(1, "Borshch"));
		dishList.add(new Dish(2, "Buckwheat porridge"));
	Почему - будет более ясно при создании unit тестов.
	
FoodCalculations.class:

	Классы всегда называются в единственном числе.
	
FoodCalculations.main method:

	Запуск приложения: 
	
		Menu:
		1. Borshch
		2. Buckwheat porridge
		3. Rice porridge
		4. Buckwheat soup
		5. Pasta with meat
		Choose a dish (enter number from 1 to 5):
		1
		Ingredients (for 1 person):
		Exception in thread "main" java.lang.NullPointerException
			at ua.com.goit.gojava.poznyak.FoodCalculations.main(FoodCalculations.java:36)
			
Ingredient.class:

	см. пожелания к Dish class
	
Ingredient.id field:

	Нужна ли где-то не используемая переменная?
	
ListService class:

	Методы возвращают список, потому их имена лучше заканчивать на List: getDishList, getIngradientList.
	Описание интерфейса потом придумаем, в зависимости от контекста.
	
ListServiceImplementation class:

	Перенеси функционал из DishStorage. И, думаю, списки в которых будешь хранить информацию - не нужно делать static.
	Пускай для каждого инстанса класса будет свой набор данных, пока не стыкнемся с обратным.
	
ListServiceImplementation.getIngredients(int dishId) method
	
	Может вернуть null. Если мы возвращаем список, но данных нету - лучше возвращать пустой список.
			
	
Диаграмма классов:

	1. Я ее перенес в trunk
	2. http://www.ibm.com/developerworks/rational/library/content/RationalEdge/sep04/bell/
	3. http://www.uml-diagrams.org/class-diagrams-overview.html	